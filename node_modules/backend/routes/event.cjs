const express = require("express");
const router = express.Router();

const { cropCred } = require("../blockchain.cjs");
const { buildEventForHash, hashEvent } = require("../utils/hashEvent.cjs");
const { validate } = require("../middleware/validate.cjs");
const { EventSchema } = require("../schemas/event.schema.cjs");

const events = new Map(); // batchId -> [events]

const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, PutCommand, QueryCommand } = require("@aws-sdk/lib-dynamodb");

const ddb = DynamoDBDocumentClient.from(new DynamoDBClient({ region: process.env.AWS_REGION }));
const EVENTS_TABLE = process.env.EVENTS_TABLE || "LifecycleEvents";


router.post("/", validate(EventSchema), async (req, res) => {
  try {
    const { batchId, certificateID, eventType, actor, payload, createdAt } = req.body;

    // âœ… Ensure createdAt is valid â€” protects Dynamo SK sorting order
    const createdAtMs = createdAt ? Date.parse(createdAt) : Date.now();
    if (!Number.isFinite(createdAtMs)) {
      return res.status(400).json({ error: "invalid_createdAt", received: createdAt });
    }


    const evt = buildEventForHash({
      batchId,
      certificateID,
      eventType,
      actor,
      payload,
      createdAt: createdAtMs,
    });

    const hash = hashEvent(evt);
    const tx = await cropCred.addEventHash(batchId, hash);
    await tx.wait();

    await ddb.send(new PutCommand({
      TableName: EVENTS_TABLE,
     Item: {
      batchId,                  // PK (S)
      createdAt: evt.createdAt, // SK (N, ms since epoch)
      certificateID,
      eventType,
      actor,
      payload: evt.payload,     // includes optional sha256
      hash,                     // canonical event hash
      txHash: tx.hash
      },
    }));


    if (!events.has(batchId)) events.set(batchId, []);
    events.get(batchId).push({ ...evt, hash });

    res.status(201).json({
      ok: true,
      batchId,
      certificateID,
      hash,
      txHash: tx.hash,
      createdAt: new Date(createdAtMs).toISOString(),
    });
  } catch (err) {
    console.error("ðŸ”¥ EVENT ROUTE ERROR:", err);
    res.status(500).json({ error: err.message });
  }
});

router.get("/batch/:batchId", async (req, res) => {
  try {
    const out = await ddb.send(new QueryCommand({
      TableName: EVENTS_TABLE,
      KeyConditionExpression: "batchId = :b",
      ExpressionAttributeValues: { ":b": req.params.batchId },
      ScanIndexForward: true
    }));
    const n = (out.Items || []).length;
    const E = 0.9, C = 0.8, D = Math.min(0.6 + n * 0.05, 0.95), S = 0.75;
    const credibilityScore = Number((((E + C + D + S) / 4) * 100).toFixed(0));
    res.json({ ok: true, batchId: req.params.batchId, count: out.Count || 0, events: out.Items || [], credibilityScore });
  } catch (e) {
    res.status(500).json({ error: "query_failed", details: e.message });
  }
});

router.get("/cert/:certificateID", async (req, res) => {
  try {
    const out = await ddb.send(new QueryCommand({
      TableName: EVENTS_TABLE,
      IndexName: "GSI1_CertificateIdCreatedAt",
      KeyConditionExpression: "certificateID = :c",
      ExpressionAttributeValues: { ":c": req.params.certificateID },
      ScanIndexForward: true
    }));
    res.json({ ok: true, count: out.Count || 0, events: out.Items || [] });
  } catch (e) {
    res.status(500).json({ error: "gsi_query_failed", details: e.message });
  }
});


module.exports = router;
module.exports.eventsStore = events;
