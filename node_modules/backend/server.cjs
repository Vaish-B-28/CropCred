require("dotenv").config();
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./swagger.cjs');

const express = require("express");
const helmet = require("helmet");
const cors = require("cors");
const { v4: uuidv4 } = require("uuid");
const batchRoutes = require('./routes/batch.cjs');


const crypto = require("crypto");

// AWS SDK
const { S3Client, PutObjectCommand, GetObjectCommand } = require("@aws-sdk/client-s3");
const { DynamoDBClient } = require("@aws-sdk/client-dynamodb");
const { DynamoDBDocumentClient, PutCommand, GetCommand, ScanCommand, QueryCommand } = require("@aws-sdk/lib-dynamodb");
const { getSignedUrl } = require("@aws-sdk/s3-request-presigner");

// Blockchain
const { ethers } = require("ethers");
const contractJson = require("./contract.json");

// ENV vars
const PRIVATE_KEY = process.env.PRIVATE_KEY || "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d";
const CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS || "0x5FbDB2315678afecb367f032d93F642f64180aa3";
const provider = new ethers.JsonRpcProvider(process.env.LOCAL_RPC_URL || "http://127.0.0.1:8545");
const signer = new ethers.Wallet(PRIVATE_KEY, provider);
const contract = new ethers.Contract(CONTRACT_ADDRESS, contractJson.abi, signer);
const { verifyToken, requireRole } = require("./middleware/auth.cjs");

const { logger } = require('./utils/logger.cjs');

// --- App init must come BEFORE any app.use() ---
const app = express();

// Security headers
app.use(helmet());

// CORS (env-driven, credentials allowed)
const corsOrigins = (process.env.CORS_ORIGINS || "http://localhost:5173")
  .split(",")
  .map(s => s.trim())
  .filter(Boolean);

app.set("trust proxy", 1);

app.use(cors({
  origin: function (origin, cb) {
    if (!origin || corsOrigins.includes(origin)) return cb(null, true);
    return cb(new Error("CORS blocked: " + origin), false);
  },
  credentials: true,
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
}));

const corsHandler = cors({
  origin: (origin, cb) => (!origin || corsOrigins.includes(origin))
    ? cb(null, true)
    : cb(new Error("CORS blocked: " + origin), false),
  credentials: true,
  methods: ["GET","POST","PUT","PATCH","DELETE","OPTIONS"],
  allowedHeaders: ["Content-Type","Authorization"],
  optionsSuccessStatus: 204, // good for some browsers
});

app.use(corsHandler); // <-- this alone is enough for OPTIONS too




// JSON body parsing AFTER CORS
app.use(express.json());

// Swagger
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// -------------------- ROUTES --------------------

// Public routes (no auth)
app.use('/api/auth', require('./routes/auth.cjs'));           // signup OTP, login (password)
app.use('/api/events', require('./routes/event.cjs'));
app.use('/api/cert', require('./routes/cert.cjs'));
app.use('/api/verify', require('./routes/verify.cjs'));       // public verify stays public

// Session continuity (token required)
app.use('/api/me', require('./routes/me.cjs'));               // GET /api/me with Bearer token

// Keep your existing mixed/protected batch routes
app.use('/api/batch', batchRoutes);                           // per-route verifyToken inside route file (if any)

// Optional farmer/consumer domains â€” mount only if files exist
try {
  const farmerRouter = require('./routes/farmer.cjs');
  app.use('/api/farmer', verifyToken, requireRole('farmer'), farmerRouter);
} catch (e) {
  console.log('â„¹ï¸  Skipping /api/farmer mount (routes/farmer.cjs not found).');
}

try {
  const consumerRouter = require('./routes/consumer.cjs');
  app.use('/api/consumer', verifyToken, requireRole('consumer'), consumerRouter);
} catch (e) {
  console.log('â„¹ï¸  Skipping /api/consumer mount (routes/consumer.cjs not found).');
}

// Credibility routes (keep these if you use them)
const credibilityRouter = require("./routes/credibility.cjs");
app.use("/api/credibility", credibilityRouter);


// âœ… Allow frontend to download certificate file from S3


app.get("/api/cert/:certificateID/download", async (req, res) => {
  try {
    const { certificateID } = req.params;

    const table = process.env.DYNAMO_TABLE || process.env.CERTIFICATES_TABLE || "Certificates";
    const bucket = process.env.S3_BUCKET || "cropcred-certificates";

    const db = await dynamo.send(new GetCommand({
      TableName: table,
      Key: { certificateID }
    }));

    if (!db.Item || !db.Item.s3Key) {
      return res.status(404).json({ error: "S3 object not found for this certificate" });
    }

    const cmd = new GetObjectCommand({
      Bucket: bucket,
      Key: db.Item.s3Key
    });

    const url = await getSignedUrl(s3, cmd, { expiresIn: 60 * 10 }); // 10 mins
    res.json({ url, key: db.Item.s3Key });

  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});


// AWS clients
const s3 = new S3Client({ region: process.env.AWS_REGION });
const dynamo = DynamoDBDocumentClient.from(new DynamoDBClient({ region: process.env.AWS_REGION }));

// --- DEBUG: list recent certificates (IDs only)
app.get("/api/debug/certs", async (req, res) => {
  try {
    const table =
      process.env.DYNAMO_TABLE ||
      process.env.CERTIFICATES_TABLE ||
      "Certificates";

    const out = await dynamo.send(
      new ScanCommand({
        TableName: table,
        ProjectionExpression: "certificateID, issuedAt",
        Limit: 100,
      })
    );

    const items = (out.Items || []).sort(
      (a, b) => new Date(b.issuedAt || 0) - new Date(a.issuedAt || 0)
    );

    res.json({ count: items.length, sample: items.slice(0, 20) });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});

// --- DEBUG: list events for a certificate via GSI1
app.get("/api/debug/events/:certificateID", async (req, res) => {
  try {
    const certificateID = req.params.certificateID;
    const IndexName = process.env.LIFECYCLE_EVENTS_GSI1 || "GSI1";
    const TableName = process.env.LIFECYCLE_EVENTS_TABLE || "LifecycleEvents";

    const out = await dynamo.send(
      new QueryCommand({
        TableName,
        IndexName,
        KeyConditionExpression: "certificateID = :cid",
        ExpressionAttributeValues: { ":cid": certificateID },
        ScanIndexForward: false,
        Limit: 50,
      })
    );



    res.json({ count: out.Count || 0, sample: out.Items || [] });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});



// âœ… Test route
app.get("/", (req, res) => res.send("Backend is running ðŸš€"));

/**
 * @swagger
 * /upload:
 *   post:
 *     summary: Upload a certificate and store metadata
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - ownerAddress
 *               - fileContent
 *             properties:
 *               name:
 *                 type: string
 *               ownerAddress:
 *                 type: string
 *               fileContent:
 *                 type: string
 *     responses:
 *       200:
 *         description: Certificate uploaded successfully
 */

// âœ… Upload route (protected)
app.post("/upload", verifyToken, async (req, res) => {
  try {
    const { name, ownerAddress, fileContent } = req.body;
    // Compute sha256 of the uploaded content (supports base64 data URLs or plain text)
let buf;
if (typeof fileContent === "string" && fileContent.startsWith("data:")) {
  // data URL like "data:application/pdf;base64,AAA..."
  const base64 = fileContent.split(",")[1] || "";
  buf = Buffer.from(base64, "base64");
} else if (typeof fileContent === "string") {
  // plain text or base64 string â€” try base64 first, fallback to utf8
  try {
    const maybe = Buffer.from(fileContent, "base64");
    // heuristic: if decoding to base64 doesnâ€™t change length drastically, keep it
    if (maybe.length > 0 && Math.abs(maybe.toString("base64").length - fileContent.length) < 5) {
      buf = maybe;
    } else {
      buf = Buffer.from(fileContent, "utf8");
    }
  } catch {
    buf = Buffer.from(fileContent, "utf8");
  }
} else if (fileContent?.type === "Buffer" && Array.isArray(fileContent.data)) {
  // if frontend sent Buffer JSON
  buf = Buffer.from(fileContent.data);
} else {
  return res.status(400).json({ error: "Unsupported fileContent format" });
}

const sha256 = crypto.createHash("sha256").update(buf).digest("hex");

    if (!name || !ownerAddress || !fileContent) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    const certificateID = uuidv4();
    const bucketName = process.env.S3_BUCKET || "cropcred-certificates";
    const key = `${certificateID}.txt`;

    // Upload file to S3
    await s3.send(new PutObjectCommand({
      Bucket: bucketName,
      Key: key,
      Body: buf, // ensure we upload the same bytes we hashed
      ContentType: "application/octet-stream"
    }));

    // Blockchain issueCertificate
    const tx = await contract.issueCertificate(certificateID, ownerAddress);
    await tx.wait();

    // Save metadata in DynamoDB
    await dynamo.send(new PutCommand({
      TableName: process.env.DYNAMO_TABLE || "Certificates",
      Item: {
        certificateID,
        name,
        ownerAddress,
        s3Key: key,
        sha256,
        txHash: tx.hash,
        issuedAt: new Date().toISOString(),
      },
    }));

    
    res.json({ message: "Certificate uploaded âœ…", certificateID, s3Key: key, sha256, txHash: tx.hash });

  } catch (err) {
    console.error("Upload failed:", err);
    res.status(500).json({ error: "Upload failed", details: err.message });
  }
});

// Simple echo test
app.post("/test", (req, res) => {
  console.log("ðŸ“¦ Test body:", req.body);
  res.json({ received: req.body });
});

/**
 * @swagger
 * /verify/{id}:
 *   get:
 *     summary: Verify a certificate against blockchain and database
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Verification result
 *       404:
 *         description: Certificate not found
 */

// âœ… Verify route
app.get("/verify/:id", async (req, res) => {
  try {
    const { id } = req.params;

    // Get from DynamoDB
    const dbResult = await dynamo.send(new GetCommand({
      TableName: process.env.DYNAMO_TABLE || "Certificates",
      Key: { certificateID: id },
    }));
    if (!dbResult.Item) return res.status(404).json({ error: "Certificate not found in DB" });

    const dbItem = dbResult.Item;

    // Get from blockchain
    const onChain = await contract.verifyCertificate(id);
    const onChainOwner = onChain.owner || onChain[1];
    const onChainIssuedAt = Number(onChain.issuedAt || onChain[2] || 0);

    const zeroAddr = "0x0000000000000000000000000000000000000000";
    const existsOnChain = onChainOwner && onChainOwner !== zeroAddr;

    let valid = false;
    try {
      if (existsOnChain) {
        valid = ethers.getAddress(onChainOwner) === ethers.getAddress(dbItem.ownerAddress);
      }
    } catch {
      valid = false;
    }

    res.json({
      db: dbItem,
      onChain: existsOnChain
        ? { certificateID: id, owner: onChainOwner, issuedAt: onChainIssuedAt }
        : null,
      valid,
    });
  } catch (err) {
    console.error("Verify failed:", err);
    res.status(500).json({ error: "Verification failed", details: err.message });
  }
});

// Public verify by batchId: returns timeline + on-chain hashes + (best) certificate
app.get("/api/public/verify/batch/:batchId", async (req, res) => {
  try {
    const batchId = req.params.batchId;

    const TableName = process.env.LIFECYCLE_EVENTS_TABLE || "LifecycleEvents";
    // events table is PK: batchId, SK: createdAt
    const out = await dynamo.send(new QueryCommand({
      TableName,
      KeyConditionExpression: "batchId = :bid",
      ExpressionAttributeValues: { ":bid": batchId },
      ScanIndexForward: true
    }));

    const events = out.Items || [];

    // choose a certificateID from events (latest or most frequent)
    let certificateID = null;
    if (events.length) {
      // pick most frequent certificateID
      const freq = new Map();
      for (const e of events) {
        if (e.certificateID) freq.set(e.certificateID, (freq.get(e.certificateID) || 0) + 1);
      }
      certificateID = [...freq.entries()].sort((a, b) => b[1] - a[1])[0]?.[0] || events[events.length - 1].certificateID || null;
    }

    // on-chain event hashes for this batchId
    let hashes = [];
    try {
      hashes = await contract.getEventHashes(batchId); // returns bytes32[] on your contract
    } catch (e) {
      // if function not present or local chain empty, keep empty array
      hashes = [];
    }

    // optional: fetch certificate doc for display (if we resolved a certificateID)
    let certificate = null;
    if (certificateID) {
      const certRes = await dynamo.send(new GetCommand({
        TableName: process.env.CERTIFICATES_TABLE || process.env.DYNAMO_TABLE || "Certificates",
        Key: { certificateID }
      }));
      certificate = certRes.Item || null;
    }

    res.json({
      batchId,
      onChain: { hashes },
      events,
      certificate,               // may be null if events had none
      certificateID,            // expose picked cert id
      credibilityApi:
        certificateID ? `/api/credibility/${certificateID}` : null
    });
  } catch (e) {
    res.status(500).json({ error: String(e) });
  }
});


/**
 * @swagger
 * /credibility/{certificateID}:
 *   get:
 *     summary: Get credibility score for a certificate
 *     parameters:
 *       - in: path
 *         name: certificateID
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Credibility score returned
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 certificateID:
 *                   type: string
 *                 credibilityScore:
 *                   type: integer
 */

// Credibility Score route
app.get("/api/credibility-legacy/:certificateID", async (req, res) => {
  try {
    const { certificateID } = req.params;

    // Replace this with your actual DB or blockchain fetch logic
    const events = await getEventsFromDB(certificateID);
    console.log("Fetched events:", events); // ðŸ” Debug log

    // âœ… Validation: check for null, undefined, or empty array
    if (!Array.isArray(events) || events.length === 0) {
      return res.status(404).json({ error: "Certificate not found or has no events" });
    }

    const score = computeCredibility(events);
    res.json({ certificateID, credibilityScore: score });
  } catch (err) {
    logger.error("Credibility error", err);
    res.status(500).json({ error: "Failed to compute credibility" });
  }
});

// Sample scoring logic
function computeCredibility(events) {
  let score = 100;

  for (const event of events) {
    // Actor trust
    if (event.actor === "unknown") score -= 10;

    // Tampering or dispute
    if (event.conditions?.tampered) score -= 20;
    if (event.notes?.includes("dispute")) score -= 15;

    // Fertilizer usage
    if (event.agri?.fertilizerUsed > 50) score -= 10;
    if (event.agri?.fertilizerUsed > 100) score -= 20;

    // Crop damage or fake
    if (event.agri?.cropStatus === "damaged") score -= 25;
    if (event.agri?.cropStatus === "fake") score -= 30;

    // Weather impact
    if (event.weather?.severity === "extreme") score -= 15;
    if (event.weather?.rainfall < 10 || event.weather?.rainfall > 300) score -= 10;
  }

  return Math.max(score, 0);
}

async function getEventsFromDB(certificateID) {
  // Simulate valid and invalid IDs
  if (certificateID === "valid123") {
    return [
      {
        actor: "farmer1",
        conditions: { tampered: false },
        notes: "clean",
        agri: { fertilizerUsed: 120, cropStatus: "damaged" },
        weather: { severity: "extreme", rainfall: 5 }
      },
      {
        actor: "unknown",
        conditions: { tampered: true },
        notes: "dispute raised",
        agri: { fertilizerUsed: 30, cropStatus: "healthy" },
        weather: { severity: "normal", rainfall: 150 }
      }
    ];
  }

  // Simulate no data for invalid IDs
  return [];
}

app.post("/api/batch/create", verifyToken, async (req, res) => {
  try {
    const { batch } = req.body;

    if (!Array.isArray(batch) || batch.length === 0) {
      return res.status(400).json({ error: "Batch must be a non-empty array" });
    }

    // Example: Validate each item in the batch
    for (const item of batch) {
      if (!item.certificateID || !item.actor) {
        return res.status(400).json({ error: "Each item must have certificateID and actor" });
      }
      // TODO: Add your logic to store/process each item
      // e.g., await CertificateModel.create(item);
    }

    logger.info(`Batch created with ${batch.length} items by ${req.user?.user || 'unknown'}`);
    res.status(200).json({ message: "Batch created successfully", count: batch.length });
  } catch (err) {
    logger.error("Batch creation error", err);
    res.status(500).json({ error: "Batch creation failed" });
  }
});

// router.get("/:batchId", ...) // list events for a batch from DynamoDB (or from the in-memory Map for now)

/**
 * @swagger
 * /health:
 *   get:
 *     summary: Health check for CropCred backend
 *     responses:
 *       200:
 *         description: Backend is running
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: CropCred backend is running
 */
app.get("/health", (req, res) => {
  res.status(200).json({ status: "CropCred backend is running" });
});

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
});
